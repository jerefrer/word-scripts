#!/usr/bin/env python3
"""Collect unique DOCX style names across files/folders and export to CSV."""

from __future__ import annotations

import argparse
import csv
import sys
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Dict, List, Sequence, Set
from zipfile import ZipFile

try:
    from docx import Document
except ImportError:  # pragma: no cover - CLI convenience only
    print("Error: python-docx library not found.", file=sys.stderr)
    print("Install it with: pip install python-docx", file=sys.stderr)
    sys.exit(1)

DOCX_SUFFIX = ".docx"
TEMP_PREFIX = "~$"
W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
W_NS_PREFIX = f"{{{W_NS}}}"
STYLE_VALUE_ATTR = f"{W_NS_PREFIX}val"
STYLE_REFERENCE_TAGS = (
    f"{W_NS_PREFIX}pStyle",
    f"{W_NS_PREFIX}rStyle",
    f"{W_NS_PREFIX}tblStyle",
    f"{W_NS_PREFIX}tcStyle",
)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Scan DOCX files (directly or via folders) and export a CSV with one "
            "row per unique style name. By default only styles actually used in "
            "content are reported."
        )
    )
    parser.add_argument(
        "paths",
        nargs="+",
        help="DOCX files or folders to scan (folders processed recursively).",
    )
    parser.add_argument(
        "-o",
        "--output",
        required=True,
        help="Destination CSV file path (single-column, alphabetized).",
    )
    parser.add_argument(
        "--include-header",
        action="store_true",
        help="If set, write a 'style' header row before the style list.",
    )
    parser.add_argument(
        "--all-styles",
        action="store_true",
        help="Include every style defined in the document (not only styles in use).",
    )
    return parser.parse_args()


def collect_docx_paths(paths: Sequence[str]) -> List[Path]:
    found: List[Path] = []
    seen = set()

    for raw_path in paths:
        path = Path(raw_path).expanduser()
        if not path.exists():
            print(f"Warning: {path} does not exist, skipping.", file=sys.stderr)
            continue

        if path.is_file():
            if _is_valid_docx(path) and path not in seen:
                found.append(path)
                seen.add(path)
            elif path.suffix.lower() != DOCX_SUFFIX:
                print(f"Warning: {path} is not a DOCX file, skipping.", file=sys.stderr)
            continue

        for docx_file in path.rglob(f"*{DOCX_SUFFIX}"):
            if _is_valid_docx(docx_file) and docx_file not in seen:
                found.append(docx_file)
                seen.add(docx_file)

    return sorted(found)


def _is_valid_docx(path: Path) -> bool:
    return (
        path.is_file()
        and path.suffix.lower() == DOCX_SUFFIX
        and not path.name.startswith(TEMP_PREFIX)
    )


def gather_style_names(docx_paths: Sequence[Path], include_all: bool) -> Set[str]:
    styles: Set[str] = set()
    for doc_path in docx_paths:
        try:
            document = Document(doc_path)
        except Exception as exc:  # pragma: no cover - runtime safety
            print(f"Error opening {doc_path}: {exc}", file=sys.stderr)
            continue

        if include_all:
            _collect_all_styles(document, styles)
        else:
            _collect_used_styles(document, doc_path, styles)
    return styles


def _collect_all_styles(document, bucket: Set[str]) -> None:
    for style in document.styles:
        name = getattr(style, "name", None)
        if name:
            bucket.add(str(name))


def _collect_used_styles(document, doc_path: Path, bucket: Set[str]) -> None:
    style_lookup = _style_id_lookup(document)
    for style_id in _extract_used_style_ids(doc_path):
        bucket.add(style_lookup.get(style_id, style_id))


def _style_id_lookup(document) -> Dict[str, str]:
    lookup: Dict[str, str] = {}
    for style in document.styles:
        style_id = getattr(style, "style_id", None)
        name = getattr(style, "name", None)
        if style_id and name:
            lookup[str(style_id)] = str(name)
    return lookup


def _extract_used_style_ids(doc_path: Path) -> Set[str]:
    used: Set[str] = set()
    try:
        with ZipFile(doc_path) as archive:
            for name in archive.namelist():
                if not name.startswith("word/") or not name.endswith(".xml"):
                    continue
                if name.endswith("styles.xml") or name.startswith("word/_rels"):
                    continue
                try:
                    root = ET.fromstring(archive.read(name))
                except ET.ParseError:
                    continue
                for tag in STYLE_REFERENCE_TAGS:
                    for elem in root.iter(tag):
                        value = elem.attrib.get(STYLE_VALUE_ATTR)
                        if value:
                            used.add(value)
    except Exception as exc:  # pragma: no cover - runtime safety
        print(f"Warning: failed to inspect {doc_path}: {exc}", file=sys.stderr)
    return used


def write_styles_csv(styles: Sequence[str], output_path: Path, include_header: bool) -> None:
    output_path = output_path.expanduser()
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with output_path.open("w", newline="", encoding="utf-8") as csv_file:
        writer = csv.writer(csv_file)
        if include_header:
            writer.writerow(["style"])
        for style_name in styles:
            writer.writerow([style_name])


def main() -> int:
    args = parse_args()
    docx_paths = collect_docx_paths(args.paths)
    if not docx_paths:
        print("No DOCX files found to process.", file=sys.stderr)
        return 1

    styles = sorted(
        gather_style_names(docx_paths, include_all=args.all_styles), key=str.lower
    )
    if not styles:
        print("No styles found in the provided files.", file=sys.stderr)
        return 1

    write_styles_csv(styles, Path(args.output), args.include_header)

    scope = "all styles" if args.all_styles else "in-use styles"
    print(
        f"Collected {len(styles)} unique {scope} from {len(docx_paths)} file(s). "
        f"CSV written to {Path(args.output).expanduser()}"
    )
    return 0


if __name__ == "__main__":
    sys.exit(main())
