#!/usr/bin/env python3
"""Fix broken Tibetan stackings inside Tibetan-styled paragraphs."""

from __future__ import annotations

import argparse
import sys
from pathlib import Path
from typing import List, Sequence, Tuple

try:
    from docx import Document
except ImportError:  # pragma: no cover - CLI ergonomics only
    print("Error: python-docx library not found.", file=sys.stderr)
    print("Install it with: pip install python-docx", file=sys.stderr)
    sys.exit(1)

DOCX_SUFFIX = ".docx"
TEMP_PREFIX = "~$"
REPLACEMENTS: Tuple[Tuple[str, str], ...] = (
    ("བིགྷྣཱན", "བིན"),
    ("བྷྱོ", "ོ"),
    ("བྷྱ", ""),
    ("གྷྲྀཧྞ", ""),
    ("གྷྲཱིཧྣ", "ཱི"),
    ("གྷྲིཧྣ", "ི"),
    ("བྷྲཱུ", ""),
    ("བྷྲཱུ", ""),
    ("ཏིཀྵྞ", "ཏི"),
    ("བིགྷྣཱྃ", "བི"),
    ("བིགྷྣན", "བིན"),
    ("དྷྱ", ""),
    ("དྷ", "དྷ"),
)

def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Replace specific broken Tibetan stacking sequences with corrected glyphs "
            "inside any paragraph whose style name contains 'Tibetan'."
        )
    )
    parser.add_argument(
        "paths",
        nargs="+",
        help="DOCX files or folders to scan (folders processed recursively).",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would change without modifying any files.",
    )
    return parser.parse_args()


def collect_docx_paths(paths: Sequence[str]) -> List[Path]:
    found: List[Path] = []
    seen = set()

    for raw_path in paths:
        path = Path(raw_path).expanduser()
        if not path.exists():
            print(f"Warning: {path} does not exist, skipping.", file=sys.stderr)
            continue

        if path.is_file():
            if _is_valid_docx(path) and path not in seen:
                found.append(path)
                seen.add(path)
            elif path.suffix.lower() != DOCX_SUFFIX:
                print(f"Warning: {path} is not a DOCX file, skipping.", file=sys.stderr)
            continue

        for docx_file in path.rglob(f"*{DOCX_SUFFIX}"):
            if _is_valid_docx(docx_file) and docx_file not in seen:
                found.append(docx_file)
                seen.add(docx_file)

    return sorted(found)


def _is_valid_docx(path: Path) -> bool:
    return (
        path.is_file()
        and path.suffix.lower() == DOCX_SUFFIX
        and not path.name.startswith(TEMP_PREFIX)
    )


def process_file(doc_path: Path, dry_run: bool) -> Tuple[int, int]:
    document = Document(doc_path)
    modified_paragraphs = 0
    replacements = 0

    for paragraph in document.paragraphs:
        if not _has_tibetan_style(paragraph):
            continue
        changed, count = _replace_sequences(paragraph)
        if changed:
            modified_paragraphs += 1
            replacements += count

    if modified_paragraphs and not dry_run:
        document.save(doc_path)

    return modified_paragraphs, replacements


def _has_tibetan_style(paragraph) -> bool:
    style = getattr(paragraph, "style", None)
    name = getattr(style, "name", "") or ""
    return "tibetan" in name.lower()


def _replace_sequences(paragraph) -> Tuple[bool, int]:
    changed = False
    replacements = 0

    for run in paragraph.runs:
        text = run.text
        if not text:
            continue
        new_text = text
        run_replacements = 0
        for old, new in REPLACEMENTS:
            occurrences = new_text.count(old)
            if not occurrences:
                continue
            new_text = new_text.replace(old, new)
            run_replacements += occurrences
        if run_replacements:
            run.text = new_text
            replacements += run_replacements
            changed = True

    return changed, replacements


def main() -> int:
    args = parse_args()
    docx_paths = collect_docx_paths(args.paths)
    if not docx_paths:
        print("No DOCX files found to process.", file=sys.stderr)
        return 1

    total_paragraphs = 0
    total_replacements = 0
    touched_files = 0
    had_errors = False

    for doc_path in docx_paths:
        try:
            modified, count = process_file(doc_path, args.dry_run)
        except Exception as exc:  # pragma: no cover - runtime safety
            had_errors = True
            print(f"Error processing {doc_path}: {exc}", file=sys.stderr)
            continue

        if modified:
            touched_files += 1
            total_paragraphs += modified
            total_replacements += count
            status = "[DRY-RUN] " if args.dry_run else ""
            print(
                f"{status}{doc_path}: applied {count} replacement(s) across "
                f"{modified} Tibetan paragraph(s)"
            )
        else:
            print(f"{doc_path}: no Tibetan paragraphs needed changes")

    print(
        f"Updated {total_paragraphs} paragraph(s) with {total_replacements} substitution(s) "
        f"across {touched_files} file(s){' (dry-run)' if args.dry_run else ''}."
    )

    if had_errors:
        print("Completed with errors.", file=sys.stderr)
        return 1
    return 0


if __name__ == "__main__":
    sys.exit(main())
