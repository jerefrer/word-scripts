#!/usr/bin/env python3
"""Rename styles inside one or many DOCX files from the command line."""

from __future__ import annotations

import argparse
import csv
import sys
from pathlib import Path
import re
from typing import Dict, Iterable, List, Sequence, Tuple

try:
    from docx import Document
    from docx.oxml import OxmlElement
    from docx.oxml.ns import qn
except ImportError:  # pragma: no cover - handled for CLI ergonomics only
    print("Error: python-docx library not found.", file=sys.stderr)
    print("Install it with: pip install python-docx", file=sys.stderr)
    sys.exit(1)


DOCX_SUFFIX = ".docx"
TEMP_PREFIX = "~$"


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Rename styles in DOCX files. Accepts paths to files and/or folders, "
            "and either a single style pair or a CSV mapping."
        )
    )
    parser.add_argument(
        "paths",
        nargs="+",
        help="DOCX files or folders to scan (folders are processed recursively)",
    )

    mapping_group = parser.add_mutually_exclusive_group(required=True)
    mapping_group.add_argument(
        "--style",
        nargs=2,
        metavar=("OLD", "NEW"),
        help="Single style rename pair (OLD name becomes NEW).",
    )
    mapping_group.add_argument(
        "--mapping-csv",
        metavar="CSV",
        help="CSV file with two columns: old style name, new style name.",
    )

    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would change without modifying any files.",
    )

    return parser.parse_args()


def collect_docx_paths(paths: Sequence[str]) -> List[Path]:
    """Expand provided paths into a unique, sorted list of DOCX files."""
    found: List[Path] = []
    seen = set()

    for raw_path in paths:
        path = Path(raw_path).expanduser()
        if not path.exists():
            print(f"Warning: {path} does not exist, skipping.", file=sys.stderr)
            continue

        if path.is_file():
            if _is_valid_docx(path) and path not in seen:
                found.append(path)
                seen.add(path)
            elif path.suffix.lower() != DOCX_SUFFIX:
                print(f"Warning: {path} is not a DOCX file, skipping.", file=sys.stderr)
            continue

        for docx_file in path.rglob(f"*{DOCX_SUFFIX}"):
            if _is_valid_docx(docx_file) and docx_file not in seen:
                found.append(docx_file)
                seen.add(docx_file)

    return sorted(found)


def _is_valid_docx(path: Path) -> bool:
    return (
        path.is_file()
        and path.suffix.lower() == DOCX_SUFFIX
        and not path.name.startswith(TEMP_PREFIX)
    )


def load_mapping_from_args(args: argparse.Namespace) -> Dict[str, str]:
    if args.style:
        old, new = (value.strip() for value in args.style)
        if not old or not new:
            raise ValueError("Style names cannot be empty.")
        if old == new:
            raise ValueError("Old and new style names are identical; nothing to rename.")
        return {old: new}

    if args.mapping_csv:
        csv_path = Path(args.mapping_csv).expanduser()
        if not csv_path.is_file():
            raise ValueError(f"Mapping CSV not found: {csv_path}")
        return _load_mapping_from_csv(csv_path)

    raise ValueError("Either --style or --mapping-csv must be provided.")


def _load_mapping_from_csv(csv_path: Path) -> Dict[str, str]:
    mapping: Dict[str, str] = {}
    with csv_path.open(newline="", encoding="utf-8-sig") as csv_file:
        reader = csv.reader(csv_file)
        for row_number, row in enumerate(reader, start=1):
            if not row:
                continue
            if len(row) < 2:
                raise ValueError(
                    f"CSV {csv_path} line {row_number} must contain at least two columns."
                )
            old, new = row[0].strip(), row[1].strip()
            if not old or not new:
                raise ValueError(
                    f"CSV {csv_path} line {row_number} contains an empty style name."
                )
            if row_number == 1 and _looks_like_header(old, new):
                continue
            if old == new:
                continue
            mapping[old] = new

    if not mapping:
        raise ValueError(f"CSV {csv_path} did not yield any style mappings.")
    return mapping


def _looks_like_header(first: str, second: str) -> bool:
    header_tokens = {"old", "old_style", "from", "source"}
    target_tokens = {"new", "new_style", "replacement", "to", "target"}
    return first.lower() in header_tokens and second.lower() in target_tokens


def rename_styles_in_file(doc_path: Path, mapping: Dict[str, str], dry_run: bool) -> Tuple[int, List[str]]:
    document = Document(doc_path)
    renamed_count = 0
    missing: List[str] = []

    for old_name, new_name in mapping.items():
        matching_styles = _find_styles_by_name(document, old_name)
        if not matching_styles:
            missing.append(old_name)
            continue

        target_style = _find_style_by_name(document, new_name)

        for style in matching_styles:
            if target_style is None or style is target_style:
                if style.name != new_name:
                    _rename_style(style, new_name)
                    renamed_count += 1
                target_style = style
                continue

            if _reassign_style_usage(document, style, target_style):
                renamed_count += 1
            _remove_style(style)

    if renamed_count and not dry_run:
        document.save(doc_path)

    return renamed_count, missing


def _rename_style(style, new_name: str) -> None:
    _set_style_name(style, new_name)
    _set_style_id(style, _style_id_from_name(new_name))


def _set_style_name(style, new_name: str) -> None:
    name_element = style.element.find(qn("w:name"))
    if name_element is None:
        name_element = OxmlElement("w:name")
        style.element.insert(0, name_element)
    name_element.set(qn("w:val"), new_name)


def _set_style_id(style, style_id: str) -> None:
    style.element.set(qn("w:styleId"), style_id)


def _style_id_from_name(name: str) -> str:
    sanitized = re.sub(r"[^0-9A-Za-z]", "", name)
    if not sanitized:
        sanitized = "Style"
    return sanitized[:31]


def _find_styles_by_name(document: Document, style_name: str) -> List:
    return [style for style in document.styles if style.name == style_name]


def _find_style_by_name(document: Document, style_name: str):
    styles = _find_styles_by_name(document, style_name)
    return styles[0] if styles else None


def _reassign_style_usage(document: Document, from_style, to_style) -> bool:
    if from_style.style_id == to_style.style_id:
        return False

    from_id = from_style.style_id
    changed = False

    for paragraph in document.paragraphs:
        if _reassign_style_in_paragraph(paragraph, from_id, to_style):
            changed = True

    for table in document.tables:
        if table.style is not None and getattr(table.style, "style_id", None) == from_id:
            table.style = to_style
            changed = True
        for row in table.rows:
            for cell in row.cells:
                for paragraph in cell.paragraphs:
                    if _reassign_style_in_paragraph(paragraph, from_id, to_style):
                        changed = True

    return changed


def _reassign_style_in_paragraph(paragraph, from_style_id: str, to_style) -> bool:
    changed = False
    if paragraph.style is not None and paragraph.style.style_id == from_style_id:
        paragraph.style = to_style
        changed = True
    for run in paragraph.runs:
        if run.style is not None and run.style.style_id == from_style_id:
            run.style = to_style
            changed = True
    return changed


def _remove_style(style) -> None:
    parent = style.element.getparent()
    if parent is not None:
        parent.remove(style.element)


def main() -> int:
    args = parse_args()
    try:
        mapping = load_mapping_from_args(args)
    except ValueError as error:
        print(f"Error: {error}", file=sys.stderr)
        return 2

    docx_paths = collect_docx_paths(args.paths)
    if not docx_paths:
        print("No DOCX files found to process.", file=sys.stderr)
        return 1

    total_files = len(docx_paths)
    total_renamed = 0
    missing_overall: Dict[str, int] = {}
    had_errors = False

    for doc_path in docx_paths:
        try:
            renamed_count, missing_for_file = rename_styles_in_file(
                doc_path, mapping, args.dry_run
            )
        except Exception as exc:  # pragma: no cover - runtime safety
            had_errors = True
            print(f"Error processing {doc_path}: {exc}", file=sys.stderr)
            continue

        total_renamed += renamed_count
        for style_name in missing_for_file:
            missing_overall[style_name] = missing_overall.get(style_name, 0) + 1

        status_prefix = "[DRY-RUN] " if args.dry_run else ""
        if renamed_count:
            print(f"{status_prefix}{doc_path}: renamed {renamed_count} style(s)")
        else:
            print(f"{status_prefix}{doc_path}: no matching styles found")

    print(
        f"Processed {total_files} file(s); "
        f"renamed {total_renamed} style instance(s){' (dry-run)' if args.dry_run else ''}."
    )

    if missing_overall:
        missing_summary = ", ".join(
            f"'{name}' missing in {count} file(s)" for name, count in missing_overall.items()
        )
        print(f"Styles not found: {missing_summary}")

    if had_errors:
        print("Completed with errors.", file=sys.stderr)
        return 1
    return 0


if __name__ == "__main__":
    sys.exit(main())
